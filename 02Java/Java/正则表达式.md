一、正则表达式术语

 1）元字符 ： 非一般字符,具有某种意义的字符。如 ： \bX ： \b边界符, 以 X开始的单词  

2）正则表达式语法大全

字符

说明

\

将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，"n"匹配字符"n"。"\n"匹配换行符。序列"\\"匹配"\"，"\("匹配"("。

^

匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与"\n"或"\r"之后的位置匹配。

$

匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与"\n"或"\r"之前的位置匹配。

*

零次或多次匹配前面的字符或子表达式。例如，zo* 匹配"z"和"zoo"。* 等效于 {0,}。

+

一次或多次匹配前面的字符或子表达式。例如，"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+ 等效于 {1,}。

?

零次或一次匹配前面的字符或子表达式。例如，"do(es)?"匹配"do"或"does"中的"do"。? 等效于 {0,1}。

{n}

n 是非负整数。正好匹配 n 次。例如，"o{2}"与"Bob"中的"o"不匹配，但与"food"中的两个"o"匹配。

{n,}

n 是非负整数。至少匹配 n 次。例如，"o{2,}"不匹配"Bob"中的"o"，而匹配"foooood"中的所有 o。"o{1,}"等效于"o+"。"o{0,}"等效于"o*"。

{n,m}

M 和 n 是非负整数，其中 n <= m。匹配至少 n 次，至多 m 次。例如，"o{1,3}"匹配"fooooood"中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。

？

当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"。

.

匹配除"\r\n"之外的任何单个字符。若要匹配包括"\r\n"在内的任意字符，请使用诸如"[\s\S]"之类的模式。

(pattern)

匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果"匹配"集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用""或者""或者""。

(?:pattern)

匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用"or"字符 (|) 组合模式部件的情况很有用。例如，'industr(?:y|ies) 是比 'industry|industries' 更经济的表达式。

(?=pattern)

执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?=95|98|NT|2000)' 匹配"Windows 2000"中的"Windows"，但不匹配"Windows 3.1"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。

(?!pattern)

执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?!95|98|NT|2000)' 匹配"Windows 3.1"中的 "Windows"，但不匹配"Windows 2000"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。

x|y

匹配 x 或 y。例如，'z|food' 匹配"z"或"food"。'(z|f)ood' 匹配"zood"或"food"。

[xyz]

字符集。匹配包含的任一字符。例如，"[abc]"匹配"plain"中的"a"。

[^xyz]

反向字符集。匹配未包含的任何字符。例如，"[^abc]"匹配"plain"中"p"，"l"，"i"，"n"。

[a-z]

字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。

[^a-z]

反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。

\b

匹配一个字边界，即字与空格间的位置。例如，"er\b"匹配"never"中的"er"，但不匹配"verb"中的"er"。

\B

非字边界匹配。"er\B"匹配"verb"中的"er"，但不匹配"never"中的"er"。

\cx

匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是"c"字符本身。

\d

数字字符匹配。等效于 [0-9]。

\D

非数字字符匹配。等效于 [^0-9]。

\f

换页符匹配。等效于 \x0c 和 \cL。

\n

换行符匹配。等效于 \x0a 和 \cJ。

\r

匹配一个回车符。等效于 \x0d 和 \cM。

\s

匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。

\S

匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。

\t

制表符匹配。与 \x09 和 \cI 等效。

\v

垂直制表符匹配。与 \x0b 和 \cK 等效。

\w

匹配任何字类字符，包括下划线。与"[A-Za-z0-9_]"等效。

\W

与任何非单词字符匹配。与"[^A-Za-z0-9_]"等效。

\xn

匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，"\x41"匹配"A"。"\x041"与"\x04"&"1"等效。允许在正则表达式中使用 ASCII 代码。

\num

匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，"(.)\1"匹配两个连续的相同字符。

\n

标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。

\nm

标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。

\nml

当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。

\un

匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。

二、Pattern类与Matcher类详解

        java.util.regex是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包。它包括两个类：Pattern和Matcher Pattern 一个Pattern是一个正则表达式经编译后的表现模式。 Matcher 一个Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。 首先一个Pattern实例订制了一个所用语法与PERL的类似的正则表达式经编译后的模式，然后一个Matcher实例在这个给定的Pattern实例的模式控制下进行字符串的匹配工作。

以下我们就分别来看看这两个类：

捕获组的概念

捕获组可以通过从左到右计算其开括号来编号，编号是从1 开始的。例如，在表达式 ((A)(B(C)))中，存在四个这样的组：

((A)(B(C)))
(A)
(B(C))
(C)
组零始终代表整个表达式。 以 (?) 开头的组是纯的非捕获 组，它不捕获文本，也不针对组合计进行计数。

       与组关联的捕获输入始终是与组最近匹配的子序列。如果由于量化的缘故再次计算了组，则在第二次计算失败时将保留其以前捕获的值（如果有的话）例如，将字符串"aba" 与表达式(a(b)?)+ 相匹配，会将第二组设置为 "b"。在每个匹配的开头，所有捕获的输入都会被丢弃。

详解Pattern类和Matcher类

       java正则表达式通过java.util.regex包下的Pattern类与Matcher类实现(建议在阅读本文时,打开java API文档,当介绍到哪个方法时,查看java API中的方法说明,效果会更佳). 
       Pattern类用于创建一个正则表达式,也可以说创建一个匹配模式,它的构造方法是私有的,不可以直接创建,但可以通过Pattern.complie(String regex)简单工厂方法创建一个正则表达式, 

Pattern p=Pattern.compile("\\w+"); 
p.pattern();//返回 \w+ 
pattern() 返回正则表达式的字符串形式,其实就是返回Pattern.complile(String regex)的regex参数

1.Pattern.split(CharSequence input)

         Pattern有一个split(CharSequence input)方法,用于分隔字符串,并返回一个String[],我猜String.split(String regex)就是通过Pattern.split(CharSequence input)来实现的. 

Pattern p=Pattern.compile("\\d+"); 
String[] str=p.split("我的QQ是:456456我的电话是:0532214我的邮箱是:aaa@aaa.com"); 
结果:str[0]="我的QQ是:" str[1]="我的电话是:" str[2]="我的邮箱是:aaa@aaa.com" 

2.Pattern.matcher(String regex,CharSequence input)是一个静态方法,用于快速匹配字符串,该方法适合用于只匹配一次,且匹配全部字符串.

Pattern.matches("\\d+","2223");//返回true 
Pattern.matches("\\d+","2223aa");//返回false,需要匹配到所有字符串才能返回true,这里aa不能匹配到 
Pattern.matches("\\d+","22bb23");//返回false,需要匹配到所有字符串才能返回true,这里bb不能匹配到 
3.Pattern.matcher(CharSequence input)

         说了这么多,终于轮到Matcher类登场了,Pattern.matcher(CharSequence input)返回一个Matcher对象.
         Matcher类的构造方法也是私有的,不能随意创建,只能通过Pattern.matcher(CharSequence input)方法得到该类的实例. 
         Pattern类只能做一些简单的匹配操作,要想得到更强更便捷的正则匹配操作,那就需要将Pattern与Matcher一起合作.Matcher类提供了对正则表达式的分组支持,以及对正则表达式的多次匹配支持. 

Pattern p=Pattern.compile("\\d+"); 
Matcher m=p.matcher("22bb23"); 
m.pattern();//返回p 也就是返回该Matcher对象是由哪个Pattern对象的创建的 
4.Matcher.matches()/ Matcher.lookingAt()/ Matcher.find()

        Matcher类提供三个匹配操作方法,三个方法均返回boolean类型,当匹配到时返回true,没匹配到则返回false 
        matches()对整个字符串进行匹配,只有整个字符串都匹配了才返回true 

Pattern p=Pattern.compile("\\d+"); 
Matcher m=p.matcher("22bb23"); 
m.matches();//返回false,因为bb不能被\d+匹配,导致整个字符串匹配未成功. 
Matcher m2=p.matcher("2223"); 
m2.matches();//返回true,因为\d+匹配到了整个字符串
       我们现在回头看一下Pattern.matcher(String regex,CharSequence input),它与下面这段代码等价 
Pattern.compile(regex).matcher(input).matches() 
lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返回true 

Pattern p=Pattern.compile("\\d+"); 
Matcher m=p.matcher("22bb23"); 
m.lookingAt();//返回true,因为\d+匹配到了前面的22 
Matcher m2=p.matcher("aa2223"); 
m2.lookingAt();//返回false,因为\d+不能匹配前面的aa 
find()对字符串进行匹配,匹配到的字符串可以在任何位置. 

Pattern p=Pattern.compile("\\d+"); 
Matcher m=p.matcher("22bb23"); 
m.find();//返回true 
Matcher m2=p.matcher("aa2223"); 
m2.find();//返回true 
Matcher m3=p.matcher("aa2223bb"); 
m3.find();//返回true 
Matcher m4=p.matcher("aabb"); 
m4.find();//返回false 
5.Mathcer.start()/ Matcher.end()/ Matcher.group()

    当使用matches(),lookingAt(),find()执行匹配操作后,就可以利用以上三个方法得到更详细的信息. 

start()返回匹配到的子字符串在字符串中的索引位置. 
end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置. 
group()返回匹配到的子字符串 
Pattern p=Pattern.compile("\\d+"); 
Matcher m=p.matcher("aaa2223bb"); 
m.find();//匹配2223 
m.start();//返回3 
m.end();//返回7,返回的是2223后的索引号 
m.group();//返回2223 

Mathcer m2=m.matcher("2223bb"); 
m.lookingAt();   //匹配2223 
m.start();   //返回0,由于lookingAt()只能匹配前面的字符串,所以当使用lookingAt()匹配时,start()方法总是返回0 
m.end();   //返回4 
m.group();   //返回2223 

Matcher m3=m.matcher("2223bb"); 
m.matches();   //匹配整个字符串 
m.start();   //返回0,原因相信大家也清楚了 
m.end();   //返回6,原因相信大家也清楚了,因为matches()需要匹配所有字符串 
m.group();   //返回2223bb 
        说了这么多,相信大家都明白了以上几个方法的使用,该说说正则表达式的分组在java中是怎么使用的. 
start(),end(),group()均有一个重载方法它们是start(int i),end(int i),group(int i)专用于分组操作,Mathcer类还有一个groupCount()用于返回有多少组. 

Pattern p=Pattern.compile("([a-z]+)(\\d+)"); 
Matcher m=p.matcher("aaa2223bb"); 
m.find();   //匹配aaa2223 
m.groupCount();   //返回2,因为有2组 
m.start(1);   //返回0 返回第一组匹配到的子字符串在字符串中的索引号 
m.start(2);   //返回3 
m.end(1);   //返回3 返回第一组匹配到的子字符串的最后一个字符在字符串中的索引位置. 
m.end(2);   //返回7 
m.group(1);   //返回aaa,返回第一组匹配到的子字符串 
m.group(2);   //返回2223,返回第二组匹配到的子字符串 
现在我们使用一下稍微高级点的正则匹配操作,例如有一段文本,里面有很多数字,而且这些数字是分开的,我们现在要将文本中所有数字都取出来,利用java的正则操作是那么的简单. 


Pattern p=Pattern.compile("\\d+"); 
Matcher m=p.matcher("我的QQ是:456456 我的电话是:0532214 我的邮箱是:aaa123@aaa.com"); 
while(m.find()) { 
     System.out.println(m.group()); 
} 

//输出: 

456456 
0532214 
123 


//如将以上while()循环替换成 

while(m.find()) { 
     System.out.println(m.group()); 
     System.out.print("start:"+m.start()); 
     System.out.println(" end:"+m.end()); 
} 

//则输出: 

456456 
start:6 end:12 
0532214 
start:19 end:26 
123 
start:36 end:39 
         现在大家应该知道,每次执行匹配操作后start(),end(),group()三个方法的值都会改变,改变成匹配到的子字符串的信息,以及它们的重载方法,也会改变成相应的信息. 
         注意:只有当匹配操作成功,才可以使用start(),end(),group()三个方法,否则会抛出java.lang.IllegalStateException,也就是当matches(),lookingAt(),find()其中任意一个方法返回true时,才可以使用.

三、常用的正则表达式：

（1）    "^\d+$"　　//非负整数（正整数 + 0）

（2）    "^[0-9]*[1-9][0-9]*$"　　//正整数

（3）    "^((-\d+)|(0+))$"　　//非正整数（负整数 + 0）

（4）    "^-[0-9]*[1-9][0-9]*$"　　//负整数

（5）    "^-?\d+$"　　　　//整数

（6）    "^\d+(\.\d+)?$"　　//非负浮点数（正浮点数 + 0）

（7）    "^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$"　　//正浮点数

（8）    "^((-\d+(\.\d+)?)|(0+(\.0+)?))$"　　//非正浮点数（负浮点数 + 0）

（9）    "^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$"　　//负浮点数

（10）  "^(-?\d+)(\.\d+)?$"　　//浮点数

（11）  "^[A-Za-z]+$"　　//由26个英文字母组成的字符串

（12）  "^[A-Z]+$"　　//由26个英文字母的大写组成的字符串

（13）  "^[a-z]+$"　　//由26个英文字母的小写组成的字符串

（14）  "^[A-Za-z0-9]+$"　　//由数字和26个英文字母组成的字符串

（15）  "^\w+$"　　//由数字、26个英文字母或者下划线组成的字符串

（16）  "^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$"　　　　//email地址

（17）  "^[a-zA-z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$"　　//url

（18）  /^(d{2}|d{4})-((0([1-9]{1}))|(1[1|2]))-(([0-2]([1-9]{1}))|(3[0|1]))$/   //  年-月-日

（19）  /^((0([1-9]{1}))|(1[1|2]))/(([0-2]([1-9]{1}))|(3[0|1]))/(d{2}|d{4})$/   // 月/日/年

（20）  "^([w-.]+)@(([[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.)|(([w-]+.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(]?)$"   //Emil

（21）  /^((\+?[0-9]{2,4}\-[0-9]{3,4}\-)|([0-9]{3,4}\-))?([0-9]{7,8})(\-[0-9]+)?$/     //电话号码

（22）  "^(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5])$"   //IP地址

（23）   

（24）  匹配中文字符的正则表达式： [\u4e00-\u9fa5]

（25）  匹配双字节字符(包括汉字在内)：[^\x00-\xff]

（26）  匹配空行的正则表达式：\n[\s| ]*\r

（27）  匹配HTML标记的正则表达式：/<(.*)>.*<\/\1>|<(.*) \/>/

（28）  匹配首尾空格的正则表达式：(^\s*)|(\s*$)

（29）  匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*

（30）  匹配网址URL的正则表达式：^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$

（31）  匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

（32）  匹配国内电话号码：(\d{3}-|\d{4}-)?(\d{8}|\d{7})?

（33）  匹配腾讯QQ号：^[1-9]*[1-9][0-9]*$

（34）  元字符及其在正则表达式上下文中的行为：

（35）  \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个后向引用、或一个八进制转义符。

（36）  ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的Multiline 属性，^ 也匹配 ’\n’ 或 ’\r’ 之后的位置。

（37）  $ 匹配输入字符串的结束位置。如果设置了 RegExp 对象的Multiline 属性，$ 也匹配 ’\n’ 或 ’\r’ 之前的位置。

（38）  * 匹配前面的子表达式零次或多次。

（39）  + 匹配前面的子表达式一次或多次。+ 等价于 {1,}。

（40）  ? 匹配前面的子表达式零次或一次。? 等价于 {0,1}。

（41）  {n} n 是一个非负整数，匹配确定的n 次。

（42）  {n,} n 是一个非负整数，至少匹配n 次。

（43）  {n,m} m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。在逗号和两个数之间不能有空格。

（44）  ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。

（45）  . 匹配除 "\n" 之外的任何单个字符。要匹配包括 ’\n’ 在内的任何字符，请使用象 ’[.\n]’ 的模式。

（46）  (pattern) 匹配pattern 并获取这一匹配。

（47）  (?:pattern) 匹配pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。

（48）  (?=pattern) 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。

（49）  (?!pattern) 负向预查，与(?=pattern)作用相反

（50）  x|y 匹配 x 或 y。

（51）  [xyz] 字符集合。

（52）  [^xyz] 负值字符集合。

（53）  [a-z] 字符范围，匹配指定范围内的任意字符。

（54）  [^a-z] 负值字符范围，匹配任何不在指定范围内的任意字符。

（55）  \b 匹配一个单词边界，也就是指单词和空格间的位置。

（56）  \B 匹配非单词边界。

（57）  \cx 匹配由x指明的控制字符。

（58）  \d 匹配一个数字字符。等价于 [0-9]。

（59）  \D 匹配一个非数字字符。等价于 [^0-9]。

（60）  \f 匹配一个换页符。等价于 \x0c 和 \cL。

（61）  \n 匹配一个换行符。等价于 \x0a 和 \cJ。

（62）  \r 匹配一个回车符。等价于 \x0d 和 \cM。

（63）  \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。

（64）  \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。

（65）  \t 匹配一个制表符。等价于 \x09 和 \cI。

（66）  \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。

（67）  \w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。

（68）  \W 匹配任何非单词字符。等价于 ’[^A-Za-z0-9_]’。

（69）  \xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。

（70）  \num 匹配 num，其中num是一个正整数。对所获取的匹配的引用。

（71）  \n 标识一个八进制转义值或一个后向引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为后向引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。

（72）  \nm 标识一个八进制转义值或一个后向引用。如果 \nm 之前至少有is preceded by at least nm 个获取得子表达式，则 nm 为后向引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的后向引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。

（73）  \nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。

（74）  \un 匹配 n，其中 n 是一个用四个十六进制数字表示的Unicode字符。

（75）  匹配中文字符的正则表达式： [u4e00-u9fa5]

（76）  匹配双字节字符(包括汉字在内)：[^x00-xff]

（77）  匹配空行的正则表达式：n[s| ]*r

（78）  匹配HTML标记的正则表达式：/<(.*)>.*</1>|<(.*) />/

（79）  匹配首尾空格的正则表达式：(^s*)|(s*$)

（80）  匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*

（81）  匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&=]*)?

（82）  利用正则表达式限制网页表单里的文本框输入内容：

（83）  用正则表达式限制只能输入中文：οnkeyup="value=value.replace(/[^u4E00-u9FA5]/g,'')" onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^u4E00-u9FA5]/g,''))"

（84）  用正则表达式限制只能输入全角字符： οnkeyup="value=value.replace(/[^uFF00-uFFFF]/g,'')" onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^uFF00-uFFFF]/g,''))"

（85）  用正则表达式限制只能输入数字：οnkeyup="value=value.replace(/[^d]/g,'') "onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^d]/g,''))"

（86）  用正则表达式限制只能输入数字和英文：οnkeyup="value=value.replace(/[W]/g,'') "onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^d]/g,''))"

（87）  整理：

（88）  匹配中文字符的正则表达式： [\u4e00-\u9fa5]

（89）  匹配双字节字符(包括汉字在内)：[^\x00-\xff]

（90）  匹配空行的正则表达式：\n[\s| ]*\r

（91）  匹配HTML标记的正则表达式：/<(.*)>.*<\/\1>|<(.*) \/>/

（92）  匹配首尾空格的正则表达式：(^\s*)|(\s*$)

（93）  匹配IP地址的正则表达式：/(\d+)\.(\d+)\.(\d+)\.(\d+)/g //

（94）  匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*

（95）  匹配网址URL的正则表达式：http://(/[\w-]+\.)+[\w-]+(/[\w- ./?%&=]*)?

（96）  sql语句：^(select|drop|delete|create|update|insert).*$

（97）  非负整数：^\d+$

（98）  正整数：^[0-9]*[1-9][0-9]*$

（99）  非正整数：^((-\d+)|(0+))$

（100）  负整数：^-[0-9]*[1-9][0-9]*$

（101）  整数：^-?\d+$

（102）  非负浮点数：^\d+(\.\d+)?$

（103）  正浮点数：^((0-9)+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$

（104）  非正浮点数：^((-\d+\.\d+)?)|(0+(\.0+)?))$

（105）  负浮点数：^(-((正浮点数正则式)))$

（106）  英文字符串：^[A-Za-z]+$

（107）  英文大写串：^[A-Z]+$

（108）  英文小写串：^[a-z]+$

（109）  英文字符数字串：^[A-Za-z0-9]+$

（110）  英数字加下划线串：^\w+$

（111）  E-mail地址：^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$

（112）  URL：^[a-zA-Z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\s*)?$

或：^http:\/\/[A-Za-z0-9]+\.[A-Za-z0-9]+[\/=\?%\-&_~`@[\]\':+!]*([^<>\"\"])*$

（113）  邮政编码：^[1-9]\d{5}$

（114）  中文：^[\u0391-\uFFE5]+$

（115）  电话号码：^((\d2,3\d2,3)|(\d{3}\-))?(0\d2,30\d2,3|0\d{2,3}-)?[1-9]\d{6,7}(\-\d{1,4})?$

（116）  手机号码：^((\d2,3\d2,3)|(\d{3}\-))?13\d{9}$

（117）  双字节字符(包括汉字在内)：^\x00-\xff

（118）  匹配首尾空格：(^\s*)|(\s*$)（像vbscript那样的trim函数）

（119）  匹配HTML标记：<(.*)>.*<\/\1>|<(.*) \/>

（120）  匹配空行：\n[\s| ]*\r

（121）  提取信息中的网络链接：(h|H)(r|R)(e|E)(f|F) *= *('|")?(\w|\\|\/|\.)+('|"| *|>)?

（122）  提取信息中的邮件地址：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*

（123）  提取信息中的图片链接：(s|S)(r|R)(c|C) *= *('|")?(\w|\\|\/|\.)+('|"| *|>)?

（124）  提取信息中的IP地址：(\d+)\.(\d+)\.(\d+)\.(\d+)

（125）  提取信息中的中国手机号码：(86)*0*13\d{9}

（126）  提取信息中的中国固定电话号码：(\d3,4\d3,4|\d{3,4}-|\s)?\d{8}

（127）  提取信息中的中国电话号码（包括移动和固定电话）：(\d3,4\d3,4|\d{3,4}-|\s)?\d{7,14}

（128）  提取信息中的中国邮政编码：[1-9]{1}(\d+){5}

（129）  提取信息中的浮点数（即小数）：(-?\d*)\.?\d+

（130）  提取信息中的任何数字 ：(-?\d*)(\.\d+)?

（131）  IP：(\d+)\.(\d+)\.(\d+)\.(\d+)

（132）  电话区号：/^0\d{2,3}$/

（133）  腾讯QQ号：^[1-9]*[1-9][0-9]*$

（134）  帐号(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

（135）  中文、英文、数字及下划线：^[\u4e00-\u9fa5_a-zA-Z0-9]+$ 